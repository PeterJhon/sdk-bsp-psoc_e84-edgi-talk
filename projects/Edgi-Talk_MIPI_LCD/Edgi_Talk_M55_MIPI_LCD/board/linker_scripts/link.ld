/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
GROUP(libgcc.a libc.a libm.a libnosys.a)
/* Define the entry point of the program, which is the reset handler */
ENTRY(Reset_Handler)

/* Define the stack size for the application */
PROVIDE(__StackSize = 0x1000);

/* Include the device memory definitions generated by the Device Configurator */
CYMEM_CM55_0_m55_data_INTERNAL_START = 0x20000000;
CYMEM_CM55_0_m55_data_SIZE = 0x00040000;
CYMEM_CM55_0_m55_data_OFFSET = 0x00000000;
CYMEM_CM55_0_m55_code_INTERNAL_START = 0x00000000;
CYMEM_CM55_0_m55_code_SIZE = 0x00040000;
CYMEM_CM55_0_m55_code_OFFSET = 0x00000000;
CYMEM_CM55_0_m55_nvm_START = 0x60580000;
CYMEM_CM55_0_m55_nvm_SIZE = 0x002FFC00;
CYMEM_CM55_0_m55_nvm_OFFSET = 0x00580000;
CYMEM_CM55_0_m55_code2_START = 0x26000000;
CYMEM_CM55_0_m55_code2_SIZE = 0x00080000;
CYMEM_CM55_0_m55_code2_OFFSET = 0x00000000;
CYMEM_CM55_0_m55_data2_START = 0x26080000;
CYMEM_CM55_0_m55_data2_SIZE = 0x00100000;
CYMEM_CM55_0_m55_data2_OFFSET = 0x00080000;
CYMEM_CM55_0_m33_m55_shared_START = 0x26180000;
CYMEM_CM55_0_m33_m55_shared_SIZE = 0x00300000;
CYMEM_CM55_0_m33_m55_shared_OFFSET = 0x00180000;
CYMEM_CM55_0_gfx_mem_START = 0x26480000;
CYMEM_CM55_0_gfx_mem_SIZE = 0x00300000;
CYMEM_CM55_0_gfx_mem_OFFSET = 0x00480000;
CYMEM_CM55_0_m33_m55_system_shared_START = 0x240FD000;
CYMEM_CM55_0_m33_m55_system_shared_SIZE = 0x00003000;
CYMEM_CM55_0_m33_m55_system_shared_OFFSET = 0x000FD000;
HYPERRAM_NS_SAHB_START           = 0x64400000;
HYPERRAM_SIZE                    = 0x00400000; /* 4MB HyperRAM */

/* The start address and size of shared memory sub-block in shared memory region for the current core
 * The approach is to have an equal sub-block for each core to avoid shared objects to be overlapped.
 * Default configuration: A sub-block for CM55 shared data will be 3rd.
 */
CORE_SYSTEM_SHARED_MEM_SIZE   = (CYMEM_CM55_0_m33_m55_system_shared_SIZE / 3);
CORE_SYSTEM_SHARED_MEM_START  = (CYMEM_CM55_0_m33_m55_system_shared_START + (2 * CORE_SYSTEM_SHARED_MEM_SIZE));

MEMORY
{
    /* Include the memory regions generated by the Device Configurator.
       This file contains the memory region definitions for the device,
       which are used to define the memory layout in this linker script. */
m55_data_INTERNAL : ORIGIN = 0x20000000, LENGTH = 0x00040000
    m55_code_INTERNAL : ORIGIN = 0x00000000, LENGTH = 0x00040000
    m55_nvm : ORIGIN = 0x60580000, LENGTH = 0x002FFC00
    m55_code2 : ORIGIN = 0x26000000, LENGTH = 0x00060800
    gfx_mem : ORIGIN = 0x26060800, LENGTH = 0x00300000
    m33_m55_shared : ORIGIN = 0x26360800, LENGTH = 0x0001F800
    m55_data2 : ORIGIN = 0x26380000, LENGTH = 0x00180000
    m33_m55_system_shared : ORIGIN = 0x240FD000, LENGTH = 0x00003000
    hyperram : ORIGIN = 0x64400000, LENGTH = 0x00400000
    /* The start address and size of shared memory sub-block in shared memory region */
    core_shared_memory : ORIGIN = CORE_SYSTEM_SHARED_MEM_START, LENGTH = CORE_SYSTEM_SHARED_MEM_SIZE
}

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 1024;

/* The size of the MCU boot header area at the start of FLASH */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section is intended to reserve a space for MCUBoot header */
    .mcu_boot_header(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m55_nvm

    /* This section is intended to hold the main application code for the Cortex-M55 */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        . = ALIGN(4);
        _stext = .;
        __text_begin = .;
        __Vectors = . ;

        KEEP(*(.vectors))

        . = ALIGN(4);

        __Vectors_End = .;

        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)
        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *cyhal_qspi.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *freertos/Source/*.* *clib-support/*.* *abstraction-rtos/*.* */cmsis/*.*) .text*)

        . = ALIGN(4);
        /* section information for utest */
        . = ALIGN(4);
        __rt_utest_tc_tab_start = .;
        KEEP(*(UtestTcTab))
        __rt_utest_tc_tab_end = .;

        /* section information for finsh shell */
        . = ALIGN(4);
        __fsymtab_start = .;
        KEEP(*(FSymTab))
        __fsymtab_end = .;
        . = ALIGN(4);
        __vsymtab_start = .;
        KEEP(*(VSymTab))
        __vsymtab_end = .;
        . = ALIGN(4);

        /* section information for modules */
        . = ALIGN(4);
        __rtmsymtab_start = .;
        KEEP(*(RTMSymTab))
        __rtmsymtab_end = .;

        /* section information for initialization */
        . = ALIGN(4);
        __rt_init_start = .;
        KEEP(*(SORT(.rti_fn*)))
        __rt_init_end = .;

        __text_end = .;
        _etext = .;
    } > m55_nvm

    . = ALIGN(4);
    .ctors :
    {
        PROVIDE(__ctors_start__ = .);
        KEEP (*(SORT(.init_array.*)))
        KEEP (*(.init_array))
        PROVIDE(__ctors_end__ = .);
    } > m55_nvm

    . = ALIGN(4);
    .dtors :
    {
        PROVIDE(__dtors_start__ = .);
        KEEP(*(SORT(.dtors.*)))
        KEEP(*(.dtors))
        PROVIDE(__dtors_end__ = .);
    } > m55_nvm

    /* Exception tables for ARM architecture */
    .ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > m55_nvm


    /* Exception index tables for ARM architecture */
    .ARM.exidx :
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;
    } > m55_nvm


    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table : ALIGN(4)
    {
        __copy_table_start__ = .;

        /* An initialized data in DTCM */
        LONG(LOADADDR(.data))       /* From */
        LONG(ADDR(.data))           /* To */
        LONG(SIZEOF(.data)/4)       /* Size in words */

        /* An initialized data in SOC memory */
        LONG(LOADADDR(.cy_socmem_data))     /* From */
        LONG(ADDR(.cy_socmem_data))         /* To */
        LONG(SIZEOF(.cy_socmem_data)/4)     /* Size in words */

        /* Code in ITCM */
        LONG (LOADADDR(.app_code_itcm)) /* From */
        LONG (ADDR(.app_code_itcm))     /* To */
        LONG (SIZEOF(.app_code_itcm)/4) /* Size in words */

        /* Code in SOC memory */
        LONG (LOADADDR(.app_code_socmem)) /* From */
        LONG (ADDR(.app_code_socmem))     /* To */
        LONG (SIZEOF(.app_code_socmem)/4) /* Size in words */

        __copy_table_end__ = .;
    } > m55_nvm

    /* Define zeroing of the uninitialized data section */
    .zero.table : ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;
    } > m55_nvm

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_itcm : ALIGN(4)
    {
        KEEP(*(.cy_itcm))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *cyhal_qspi.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *freertos/Source/*.*(.text*)
        *clib-support/*.*(.text*)
        *abstraction-rtos/*.*(.text*)
        */cmsis/*.*(.text*)

        . = ALIGN(4);
    } > m55_code_INTERNAL AT > m55_nvm

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        __ram_vectors_start__ = .;

        KEEP(*(.ram_vectors))

        __ram_vectors_end__ = .;
    } > m55_code_INTERNAL

    /* A section for less performance-sensitive or critical functions that might be executed in SOC memory */
    .app_code_socmem : ALIGN(4)
    {
        KEEP(*(.cy_socmem_code))

        . = ALIGN(4);
    }  > m55_code2 AT > m55_nvm

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(vtable)
        *(.data*)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN (__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN (__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN (__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN (__fini_array_end = .);

        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m55_data_INTERNAL AT > m55_nvm

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) : ALIGN(8)
    {
        __noinit_start__ = .;

        KEEP(*(.noinit))

        . = ALIGN(4);

        __noinit_end__ = .;
    } > m55_data_INTERNAL

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m55_data_INTERNAL

    __StackTop = ORIGIN(m55_data_INTERNAL) + LENGTH(m55_data_INTERNAL);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if .data + .noinit + .bss + stack exceeds RAM limit in region m55_data_INTERNAL */
    ASSERT(
      __StackLimit >= __bss_end__,
      "Error: m55_data_INTERNAL region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* A section for SOC memory data */
    .cy_socmem_data : ALIGN(4)
    {
        KEEP(*(.cy_socmem_data))

        . = ALIGN(4);

    }  > m55_data2 AT > m55_nvm

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ORIGIN(m55_data2) + LENGTH(m55_data2);

        __HeapLimit = .;
    } > m55_data2

    /* A section for the GPU buffer */
    .cy_gpu_buf(NOLOAD) :
    {
        KEEP(*(.cy_gpu_buf))
    } > gfx_mem

    .reserved_socmem(NOLOAD) :
    {
        . = ORIGIN(m33_m55_shared) + LENGTH(m33_m55_shared); /* reserved SOC memory */
    } > m33_m55_shared


    /* A section for shared RAM memory */
    .cy_sharedmem(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_sharedmem))

        . = ALIGN(4);
    } > core_shared_memory

    /* A section for HyperRAM memory */
    .cy_hyperram(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_hyperram))

        . = ALIGN(4);
    } > hyperram
}

