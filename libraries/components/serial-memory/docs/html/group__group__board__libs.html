<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>(serial-memory)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">(serial-memory)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__board__libs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Serial Memory</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >In addition to the APIs for reading and writing to memory at runtime, this library also provides support for informing programming tools about the external memory so it can be be written at the same time as internal memory. </p>
<h1><a class="anchor" id="section_qspi_configurator_to_smif"></a>
QSPI configurator slave slot correlation with pins</h1>
<p >In QSPI configurator Memory Parts are tied to a specific slave slot that is linked to the actual slave select pin mappings of that specific device. So selecting a memory configuration for slot 0 means that physically that external memory will be the connected to slave select 0 pin. This is important for kits that have hardwired connections to external memories where the memory configuration needs to be in the correct slot depending on what slave select pin is hardwired to it.</p>
<h1><a class="anchor" id="section_serial_memory_octal_ddr_handling"></a>
Serial Memory handling for Octal DDR</h1>
<p >For external memories that are configured in Octal DDR mode, read/write operations at odd addresses and with length equal to 1 are not natively supported due to limitations in the protocol that requires an even address and/or even lengths. For this reason a special handling of these cases is present in <a class="el" href="group__group__board__libs.html#gacad7efda0b4e3e8a87e5f76b138373f1">mtb_serial_memory_read</a> and <a class="el" href="group__group__board__libs.html#gac6dff8a6582db130b48aeaf2d416f512">mtb_serial_memory_write</a> to allow the use of odd addresses in a transparent way for the user.</p>
<p >For <a class="el" href="group__group__board__libs.html#gacad7efda0b4e3e8a87e5f76b138373f1">mtb_serial_memory_read</a> when selecting a read one byte at an odd address, the function will instead perform a read at the even address preceding the specified address and then discard the extra byte returning to the user only the data they requested.</p>
<p >For <a class="el" href="group__group__board__libs.html#gac6dff8a6582db130b48aeaf2d416f512">mtb_serial_memory_write</a> the function needs to take into consideration all four possible combination of even/odd addresses and lengths:</p><ul>
<li>For even addresses, even lengths the function directly calls the PDL write function, this is the standard use case</li>
<li>For even addresses, length equal to one byte the function first reads the memory for 2 bytes and then creates a new write buffer copying the user's input buffer and making sure the last byte is not altered using the data it previously read WARNING: This will essentially write a byte past the intended one with its existing value that was previously read. Ensure that your memory can support this.</li>
<li>For even addresses, odd lengths greater than one the function will return an error as this is an unsupported use case</li>
<li>For odd addresses, even lengths the function will return an error as this is an unsupported use case</li>
<li>For odd addresses, length equal to one byte the function first reads the memory for 2 bytes starting at the even address preceding the specified address to and then creates a new write buffer copying the user's input buffer and making sure the first byte will not be altered using the data it previously read. WARNING: This will rewrite a location that has already been written (with its existing value). Ensure that your memory can support this.</li>
<li>For odd addresses, odd lengths greater than one the function will return an error as this is an unsupported use case.</li>
</ul>
<p >This special handling needs to be enabled by setting define in _MTB_SERIAL_MEMORY_EMULATE_BYTE_ADDRESSABLE the application Makefile.</p>
<p >This support can be enabled by defining MTB_SERIAL_MEMORY_ENABLE_XIP_PROGRAM while building the application. With this define in place, code will be generated in the .cy_sflash_user_data &amp; .cy_toc_part2 sections. These sections must be provided by the linker script for the application. One the application has been built, these locations can be read by programming tools (eg: Cypress Programmer, OpenOCD, pyOCD) to know that there is a memory device attached and how to program it. </p><dl class="section note"><dt>Note</dt><dd>This support is not compatible with the PSoCâ„¢ 64 series of devices. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structmtb__serial__memory__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a></td></tr>
<tr class="memdesc:structmtb__serial__memory__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial memory object.  <a href="group__group__board__libs.html#structmtb__serial__memory__t">More...</a><br /></td></tr>
<tr class="separator:structmtb__serial__memory__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga500e35a3bc2d90041ab1bc9eab989606"><td class="memItemLeft" align="right" valign="top"><a id="ga500e35a3bc2d90041ab1bc9eab989606" name="ga500e35a3bc2d90041ab1bc9eab989606"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_SERIAL_MEMORY_THREAD_SAFE</b></td></tr>
<tr class="memdesc:ga500e35a3bc2d90041ab1bc9eab989606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables thread-safety for use with multi-threaded RTOS environment. <br /></td></tr>
<tr class="separator:ga500e35a3bc2d90041ab1bc9eab989606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba152cdbee6337a0535daa88d8f071ab"><td class="memItemLeft" align="right" valign="top"><a id="gaba152cdbee6337a0535daa88d8f071ab" name="gaba152cdbee6337a0535daa88d8f071ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_IP_MXSMIF</b></td></tr>
<tr class="memdesc:gaba152cdbee6337a0535daa88d8f071ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MXSMIF IP is available. <br /></td></tr>
<tr class="separator:gaba152cdbee6337a0535daa88d8f071ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9670db76ab45eb5283ab8c9579a29537"><td class="memItemLeft" align="right" valign="top"><a id="ga9670db76ab45eb5283ab8c9579a29537" name="ga9670db76ab45eb5283ab8c9579a29537"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_RSLT_SERIAL_MEMORY_ERR_UNSUPPORTED</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_MEMORY, 1))</td></tr>
<tr class="memdesc:ga9670db76ab45eb5283ab8c9579a29537"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function or operation is not supported on the target or the memory. <br /></td></tr>
<tr class="separator:ga9670db76ab45eb5283ab8c9579a29537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c2d9f748508fabfde2593d48a44622"><td class="memItemLeft" align="right" valign="top"><a id="ga15c2d9f748508fabfde2593d48a44622" name="ga15c2d9f748508fabfde2593d48a44622"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_RSLT_SERIAL_MEMORY_ERR_BAD_PARAM</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_MEMORY, 2))</td></tr>
<tr class="memdesc:ga15c2d9f748508fabfde2593d48a44622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters passed to a function are invalid. <br /></td></tr>
<tr class="separator:ga15c2d9f748508fabfde2593d48a44622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888f50f0273a8a1c3c11f6e35cfac33c"><td class="memItemLeft" align="right" valign="top"><a id="ga888f50f0273a8a1c3c11f6e35cfac33c" name="ga888f50f0273a8a1c3c11f6e35cfac33c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_RSLT_SERIAL_MEMORY_ERR_READ_BUSY</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_MEMORY, 3))</td></tr>
<tr class="memdesc:ga888f50f0273a8a1c3c11f6e35cfac33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A previously initiated read operation is not yet complete. <br /></td></tr>
<tr class="separator:ga888f50f0273a8a1c3c11f6e35cfac33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43365fc2173092defcc9030ee41a08b"><td class="memItemLeft" align="right" valign="top"><a id="gaf43365fc2173092defcc9030ee41a08b" name="gaf43365fc2173092defcc9030ee41a08b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_RSLT_SERIAL_MEMORY_ERR_OCTAL_ENABLE</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_MEMORY, 4))</td></tr>
<tr class="memdesc:gaf43365fc2173092defcc9030ee41a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting octal enabled failed. <br /></td></tr>
<tr class="separator:gaf43365fc2173092defcc9030ee41a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba908db36711d863ed3b650b9c3bef4"><td class="memItemLeft" align="right" valign="top"><a id="ga7ba908db36711d863ed3b650b9c3bef4" name="ga7ba908db36711d863ed3b650b9c3bef4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_RSLT_SERIAL_MEMORY_ERR_RX_CAPTURE</b>&#160;&#160;&#160;    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_MEMORY, 5))</td></tr>
<tr class="memdesc:ga7ba908db36711d863ed3b650b9c3bef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting rx capture mode failed. <br /></td></tr>
<tr class="separator:ga7ba908db36711d863ed3b650b9c3bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7c7e310e48ba18be1ff7a56bd99ecdb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__board__libs.html#gga7c7e310e48ba18be1ff7a56bd99ecdb4ac3ddbcc9acc10e160225636a8dbcaadd">MTB_SERIAL_MEMORY_CHIP_SELECT_0</a> = 1u
, <br />
&#160;&#160;<a class="el" href="group__group__board__libs.html#gga7c7e310e48ba18be1ff7a56bd99ecdb4a14f903d280795f0dea02b6886b4b3f6c">MTB_SERIAL_MEMORY_CHIP_SELECT_1</a> = 1u &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="group__group__board__libs.html#gga7c7e310e48ba18be1ff7a56bd99ecdb4ae8fc443f5c578ce12338de643c87a431">MTB_SERIAL_MEMORY_CHIP_SELECT_2</a> = 1u &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="group__group__board__libs.html#gga7c7e310e48ba18be1ff7a56bd99ecdb4a772c94cab78660c3109e8069ceda78b6">MTB_SERIAL_MEMORY_CHIP_SELECT_3</a> = 1u &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:ga7c7e310e48ba18be1ff7a56bd99ecdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial Memory Chip Select Each chip select is represented by an enumeration that has the bit corresponding to the chip select number set.  <a href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">More...</a><br /></td></tr>
<tr class="separator:ga7c7e310e48ba18be1ff7a56bd99ecdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac0fa5fb0a61f10b3bdfe281c66a9caf8"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gac0fa5fb0a61f10b3bdfe281c66a9caf8">mtb_serial_memory_setup</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, <a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a> smif_active_chip, SMIF_Type *base, const mtb_hal_clock_t *clock, cy_stc_smif_context_t *context, const cy_stc_smif_block_config_t *block_config)</td></tr>
<tr class="memdesc:gac0fa5fb0a61f10b3bdfe281c66a9caf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the serial memory.  <a href="group__group__board__libs.html#gac0fa5fb0a61f10b3bdfe281c66a9caf8">More...</a><br /></td></tr>
<tr class="separator:gac0fa5fb0a61f10b3bdfe281c66a9caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226540e2b77f0873e6fc84a56490f142"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga226540e2b77f0873e6fc84a56490f142">mtb_serial_memory_get_size</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj)</td></tr>
<tr class="memdesc:ga226540e2b77f0873e6fc84a56490f142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the serial memory in bytes.  <a href="group__group__board__libs.html#ga226540e2b77f0873e6fc84a56490f142">More...</a><br /></td></tr>
<tr class="separator:ga226540e2b77f0873e6fc84a56490f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a58bd4dd940f80e068d4713ca76c0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga41a58bd4dd940f80e068d4713ca76c0c">mtb_serial_memory_get_erase_size</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr)</td></tr>
<tr class="memdesc:ga41a58bd4dd940f80e068d4713ca76c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the erase sector to which the given address belongs.  <a href="group__group__board__libs.html#ga41a58bd4dd940f80e068d4713ca76c0c">More...</a><br /></td></tr>
<tr class="separator:ga41a58bd4dd940f80e068d4713ca76c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade86554198c0e33962c935497156fbf2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gade86554198c0e33962c935497156fbf2">mtb_serial_memory_get_prog_size</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr)</td></tr>
<tr class="memdesc:gade86554198c0e33962c935497156fbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page size for programming of the sector to which the given address belongs.  <a href="group__group__board__libs.html#gade86554198c0e33962c935497156fbf2">More...</a><br /></td></tr>
<tr class="separator:gade86554198c0e33962c935497156fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa106fd4cae916790481851271a65f793"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaa106fd4cae916790481851271a65f793">mtb_serial_memory_get_sector_start_address</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr)</td></tr>
<tr class="memdesc:gaa106fd4cae916790481851271a65f793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to calculate the starting address of an erase sector to which the given address belongs.  <a href="group__group__board__libs.html#gaa106fd4cae916790481851271a65f793">More...</a><br /></td></tr>
<tr class="separator:gaa106fd4cae916790481851271a65f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad7efda0b4e3e8a87e5f76b138373f1"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gacad7efda0b4e3e8a87e5f76b138373f1">mtb_serial_memory_read</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr, size_t length, uint8_t *buf)</td></tr>
<tr class="memdesc:gacad7efda0b4e3e8a87e5f76b138373f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the serial memory.  <a href="group__group__board__libs.html#gacad7efda0b4e3e8a87e5f76b138373f1">More...</a><br /></td></tr>
<tr class="separator:gacad7efda0b4e3e8a87e5f76b138373f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6dff8a6582db130b48aeaf2d416f512"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gac6dff8a6582db130b48aeaf2d416f512">mtb_serial_memory_write</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr, size_t length, const uint8_t *buf)</td></tr>
<tr class="memdesc:gac6dff8a6582db130b48aeaf2d416f512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data to the serial memory.  <a href="group__group__board__libs.html#gac6dff8a6582db130b48aeaf2d416f512">More...</a><br /></td></tr>
<tr class="separator:gac6dff8a6582db130b48aeaf2d416f512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04cd6732a9a1eedb5c5e9fd3050a7bf2"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga04cd6732a9a1eedb5c5e9fd3050a7bf2">mtb_serial_memory_erase</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, uint32_t addr, size_t length)</td></tr>
<tr class="memdesc:ga04cd6732a9a1eedb5c5e9fd3050a7bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the serial memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command.  <a href="group__group__board__libs.html#ga04cd6732a9a1eedb5c5e9fd3050a7bf2">More...</a><br /></td></tr>
<tr class="separator:ga04cd6732a9a1eedb5c5e9fd3050a7bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2f093cd216c1b0382490fb60582867e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaa2f093cd216c1b0382490fb60582867e">mtb_serial_memory_enable_xip</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, bool enable)</td></tr>
<tr class="memdesc:gaa2f093cd216c1b0382490fb60582867e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Execute-in-Place (memory mapped) mode on the MCU.  <a href="group__group__board__libs.html#gaa2f093cd216c1b0382490fb60582867e">More...</a><br /></td></tr>
<tr class="separator:gaa2f093cd216c1b0382490fb60582867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16c49cc62aa0a824188271fccc08d58"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaf16c49cc62aa0a824188271fccc08d58">mtb_serial_memory_set_active_chip</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, <a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a> chip_select)</td></tr>
<tr class="memdesc:gaf16c49cc62aa0a824188271fccc08d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active memory device that the serial-flash functions perform the operations on.  <a href="group__group__board__libs.html#gaf16c49cc62aa0a824188271fccc08d58">More...</a><br /></td></tr>
<tr class="separator:gaf16c49cc62aa0a824188271fccc08d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb10369f0600df41a468c2f2723ced8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga0bb10369f0600df41a468c2f2723ced8">mtb_serial_memory_get_chip_count</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj)</td></tr>
<tr class="memdesc:ga0bb10369f0600df41a468c2f2723ced8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of memory devices successfully initialized.  <a href="group__group__board__libs.html#ga0bb10369f0600df41a468c2f2723ced8">More...</a><br /></td></tr>
<tr class="separator:ga0bb10369f0600df41a468c2f2723ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d333067d0a473ffe3d31308bd87b5ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga8d333067d0a473ffe3d31308bd87b5ae">mtb_serial_memory_get_active_chip</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj)</td></tr>
<tr class="memdesc:ga8d333067d0a473ffe3d31308bd87b5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the active chip select.  <a href="group__group__board__libs.html#ga8d333067d0a473ffe3d31308bd87b5ae">More...</a><br /></td></tr>
<tr class="separator:ga8d333067d0a473ffe3d31308bd87b5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad86f5349a0985739add0ce4dfb740c5"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaad86f5349a0985739add0ce4dfb740c5">mtb_serial_memory_set_write_enable</a> (<a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *obj, bool enable)</td></tr>
<tr class="memdesc:gaad86f5349a0985739add0ce4dfb740c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the Write Enable or Write Disable command to the external memory.  <a href="group__group__board__libs.html#gaad86f5349a0985739add0ce4dfb740c5">More...</a><br /></td></tr>
<tr class="separator:gaad86f5349a0985739add0ce4dfb740c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structmtb__serial__memory__t" id="structmtb__serial__memory__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmtb__serial__memory__t">&#9670;&nbsp;</a></span>mtb_serial_memory_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mtb_serial_memory_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a647b23728de1c551b786ebc5053680dd" name="a647b23728de1c551b786ebc5053680dd"></a>uint32_t</td>
<td class="fieldname">
smif_instance</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac2dce6ace3bbbaa1a106efe8a03c4998" name="ac2dce6ace3bbbaa1a106efe8a03c4998"></a>uint32_t</td>
<td class="fieldname">
smif_active_slot</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2ef3e3ab086e7a44da95e64126454183" name="a2ef3e3ab086e7a44da95e64126454183"></a>SMIF_Type *</td>
<td class="fieldname">
base</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ab5f7159b548ef6816795fd68bfcea220" name="ab5f7159b548ef6816795fd68bfcea220"></a>const mtb_hal_clock_t *</td>
<td class="fieldname">
clock</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ab05518d8903441b96dbe7411b0c02d6c" name="ab05518d8903441b96dbe7411b0c02d6c"></a>cy_stc_smif_context_t *</td>
<td class="fieldname">
context</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af496e91a2e7faf4f3b45ca11b4aec854" name="af496e91a2e7faf4f3b45ca11b4aec854"></a>uint32_t</td>
<td class="fieldname">
configured_csel</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8ada53bf3fe5aea86c4ddddcfd1918b4" name="a8ada53bf3fe5aea86c4ddddcfd1918b4"></a>uint32_t</td>
<td class="fieldname">
chip_select</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa98d5b106e0ff7fa84bda76f72b94ae8" name="aa98d5b106e0ff7fa84bda76f72b94ae8"></a>const cy_stc_smif_block_config_t *</td>
<td class="fieldname">
smif_block_config</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6bef17cc1af859964013dee88f9d304a" name="a6bef17cc1af859964013dee88f9d304a"></a>uint32_t</td>
<td class="fieldname">
status_flags</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a220d588de6eeda8fb5d8ee97f27fe1a4" name="a220d588de6eeda8fb5d8ee97f27fe1a4"></a>cy_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7c7e310e48ba18be1ff7a56bd99ecdb4" name="ga7c7e310e48ba18be1ff7a56bd99ecdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c7e310e48ba18be1ff7a56bd99ecdb4">&#9670;&nbsp;</a></span>mtb_serial_memory_chip_select_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial Memory Chip Select Each chip select is represented by an enumeration that has the bit corresponding to the chip select number set. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7c7e310e48ba18be1ff7a56bd99ecdb4ac3ddbcc9acc10e160225636a8dbcaadd" name="gga7c7e310e48ba18be1ff7a56bd99ecdb4ac3ddbcc9acc10e160225636a8dbcaadd"></a>MTB_SERIAL_MEMORY_CHIP_SELECT_0&#160;</td><td class="fielddoc"><p >The SMIF chip select 0 <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c7e310e48ba18be1ff7a56bd99ecdb4a14f903d280795f0dea02b6886b4b3f6c" name="gga7c7e310e48ba18be1ff7a56bd99ecdb4a14f903d280795f0dea02b6886b4b3f6c"></a>MTB_SERIAL_MEMORY_CHIP_SELECT_1&#160;</td><td class="fielddoc"><p >The SMIF chip select 1 <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c7e310e48ba18be1ff7a56bd99ecdb4ae8fc443f5c578ce12338de643c87a431" name="gga7c7e310e48ba18be1ff7a56bd99ecdb4ae8fc443f5c578ce12338de643c87a431"></a>MTB_SERIAL_MEMORY_CHIP_SELECT_2&#160;</td><td class="fielddoc"><p >The SMIF chip select 2 <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c7e310e48ba18be1ff7a56bd99ecdb4a772c94cab78660c3109e8069ceda78b6" name="gga7c7e310e48ba18be1ff7a56bd99ecdb4a772c94cab78660c3109e8069ceda78b6"></a>MTB_SERIAL_MEMORY_CHIP_SELECT_3&#160;</td><td class="fielddoc"><p >The SMIF chip select 3 <br  />
 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac0fa5fb0a61f10b3bdfe281c66a9caf8" name="gac0fa5fb0a61f10b3bdfe281c66a9caf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0fa5fb0a61f10b3bdfe281c66a9caf8">&#9670;&nbsp;</a></span>mtb_serial_memory_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a>&#160;</td>
          <td class="paramname"><em>smif_active_chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SMIF_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtb_hal_clock_t *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_stc_smif_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_smif_block_config_t *&#160;</td>
          <td class="paramname"><em>block_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the serial memory. </p>
<dl class="section note"><dt>Note</dt><dd>The function will reset the memory controller when "Auto Detect SFDP" is chosen in the "Memory Part Number" section of the QSPI Configurator. However, if a specific part number is specified in the QSPI Configurator, the responsibility falls to the application to reset the memory controller using the Cy_SMIF_Reset_Memory() PDL function. This approach is adopted because the <a class="el" href="group__group__board__libs.html#gac0fa5fb0a61f10b3bdfe281c66a9caf8" title="Sets up the serial memory.">mtb_serial_memory_setup()</a> function might be executed from the external memory itself, and resetting the memory controller could disrupt the communication with the memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to setup </td></tr>
    <tr><td class="paramname">smif_active_chip</td><td>The slave select line to configure as active </td></tr>
    <tr><td class="paramname">base</td><td>Pointer to the SMIf base address </td></tr>
    <tr><td class="paramname">clock</td><td>Pointer to the clock object </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to the SMIF ip context structure </td></tr>
    <tr><td class="paramname">block_config</td><td>Pointer to the SMIF block configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the setup was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga226540e2b77f0873e6fc84a56490f142" name="ga226540e2b77f0873e6fc84a56490f142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga226540e2b77f0873e6fc84a56490f142">&#9670;&nbsp;</a></span>mtb_serial_memory_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtb_serial_memory_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the serial memory in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to obtain information from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory size in bytes. </dd></dl>

</div>
</div>
<a id="ga41a58bd4dd940f80e068d4713ca76c0c" name="ga41a58bd4dd940f80e068d4713ca76c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a58bd4dd940f80e068d4713ca76c0c">&#9670;&nbsp;</a></span>mtb_serial_memory_get_erase_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtb_serial_memory_get_erase_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the erase sector to which the given address belongs. </p>
<p >Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to obtain information from. </td></tr>
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erase sector size in bytes. </dd></dl>

</div>
</div>
<a id="gade86554198c0e33962c935497156fbf2" name="gade86554198c0e33962c935497156fbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade86554198c0e33962c935497156fbf2">&#9670;&nbsp;</a></span>mtb_serial_memory_get_prog_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtb_serial_memory_get_prog_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the page size for programming of the sector to which the given address belongs. </p>
<p >Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to obtain information from. </td></tr>
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Page size in bytes. </dd></dl>

</div>
</div>
<a id="gaa106fd4cae916790481851271a65f793" name="gaa106fd4cae916790481851271a65f793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa106fd4cae916790481851271a65f793">&#9670;&nbsp;</a></span>mtb_serial_memory_get_sector_start_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t mtb_serial_memory_get_sector_start_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to calculate the starting address of an erase sector to which the given address belongs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to obtain information from. </td></tr>
    <tr><td class="paramname">addr</td><td>Address in the sector for which the starting address is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Starting address of the sector </dd></dl>

</div>
</div>
<a id="gacad7efda0b4e3e8a87e5f76b138373f1" name="gacad7efda0b4e3e8a87e5f76b138373f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad7efda0b4e3e8a87e5f76b138373f1">&#9670;&nbsp;</a></span>mtb_serial_memory_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the serial memory. </p>
<p >This is a blocking function. Returns error if (addr + length) exceeds the memory size. If _MTB_SERIAL_MEMORY_EMULATE_BYTE_ADDRESSABLE is set the function can emulate byte addressable memories for Octal DDR memories and handle one byte reads even at odd addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to obtain information from. </td></tr>
    <tr><td class="paramname">addr</td><td>Starting address to read from </td></tr>
    <tr><td class="paramname">length</td><td>Number of data bytes to read </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer to store the data read from the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the read was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="gac6dff8a6582db130b48aeaf2d416f512" name="gac6dff8a6582db130b48aeaf2d416f512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6dff8a6582db130b48aeaf2d416f512">&#9670;&nbsp;</a></span>mtb_serial_memory_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data to the serial memory. </p>
<p >The program area must have been erased prior to calling this API using <a class="el" href="group__group__board__libs.html#ga04cd6732a9a1eedb5c5e9fd3050a7bf2">mtb_serial_memory_erase()</a> This is a blocking function. Returns error if (addr + length) exceeds the memory size. If _MTB_SERIAL_MEMORY_EMULATE_BYTE_ADDRESSABLE is set the function can emulate byte addressable memories for Octal DDR memories and handle one byte writes even at odd addresses. This however actually writes starting from the previous even address and will always write two bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to write to. </td></tr>
    <tr><td class="paramname">addr</td><td>Starting address to write to </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer storing the data to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the write was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga04cd6732a9a1eedb5c5e9fd3050a7bf2" name="ga04cd6732a9a1eedb5c5e9fd3050a7bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04cd6732a9a1eedb5c5e9fd3050a7bf2">&#9670;&nbsp;</a></span>mtb_serial_memory_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the serial memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command. </p>
<p >This is a blocking function. Returns error if addr or (addr + length) is not aligned to the sector size or if (addr + length) exceeds the memory size. For memories with hybrid sectors, returns error if the end address (=addr + length) is not aligned to the size of the sector in which the end address is located. Call <a class="el" href="group__group__board__libs.html#ga226540e2b77f0873e6fc84a56490f142">mtb_serial_memory_get_size()</a> to get the flash size and call <a class="el" href="group__group__board__libs.html#ga41a58bd4dd940f80e068d4713ca76c0c">mtb_serial_memory_get_erase_size()</a> to get the size of an erase sector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to erase. </td></tr>
    <tr><td class="paramname">addr</td><td>Starting address to begin erasing </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the erase was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="gaa2f093cd216c1b0382490fb60582867e" name="gaa2f093cd216c1b0382490fb60582867e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2f093cd216c1b0382490fb60582867e">&#9670;&nbsp;</a></span>mtb_serial_memory_enable_xip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_enable_xip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Execute-in-Place (memory mapped) mode on the MCU. </p>
<p >This function does not send any command to the serial memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to enable XIP on. </td></tr>
    <tr><td class="paramname">enable</td><td>true: XIP mode is set, false: normal mode is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the operation was successful. </dd></dl>

</div>
</div>
<a id="gaf16c49cc62aa0a824188271fccc08d58" name="gaf16c49cc62aa0a824188271fccc08d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16c49cc62aa0a824188271fccc08d58">&#9670;&nbsp;</a></span>mtb_serial_memory_set_active_chip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_set_active_chip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#ga7c7e310e48ba18be1ff7a56bd99ecdb4">mtb_serial_memory_chip_select_t</a>&#160;</td>
          <td class="paramname"><em>chip_select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the active memory device that the serial-flash functions perform the operations on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to set active chip for. </td></tr>
    <tr><td class="paramname">chip_select</td><td>The chip select of the memory device to be set as active. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function will return an error if the device had not been setup with <a class="el" href="group__group__board__libs.html#gac0fa5fb0a61f10b3bdfe281c66a9caf8">mtb_serial_memory_setup</a> . </dd></dl>

</div>
</div>
<a id="ga0bb10369f0600df41a468c2f2723ced8" name="ga0bb10369f0600df41a468c2f2723ced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb10369f0600df41a468c2f2723ced8">&#9670;&nbsp;</a></span>mtb_serial_memory_get_chip_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mtb_serial_memory_get_chip_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of memory devices successfully initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to get chip count for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of memory devices successfully initialized. </dd></dl>

</div>
</div>
<a id="ga8d333067d0a473ffe3d31308bd87b5ae" name="ga8d333067d0a473ffe3d31308bd87b5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d333067d0a473ffe3d31308bd87b5ae">&#9670;&nbsp;</a></span>mtb_serial_memory_get_active_chip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mtb_serial_memory_get_active_chip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the active chip select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to get the active chip for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the active memory chip. </dd></dl>

</div>
</div>
<a id="gaad86f5349a0985739add0ce4dfb740c5" name="gaad86f5349a0985739add0ce4dfb740c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad86f5349a0985739add0ce4dfb740c5">&#9670;&nbsp;</a></span>mtb_serial_memory_set_write_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_serial_memory_set_write_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t">mtb_serial_memory_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the Write Enable or Write Disable command to the external memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the <a class="el" href="group__group__board__libs.html#structmtb__serial__memory__t" title="Serial memory object.">mtb_serial_memory_t</a> object to send write enable/disable command to. </td></tr>
    <tr><td class="paramname">enable</td><td>if true the command to be sent is Write Enable, if false the command to be sent is Write Disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the operation was successful, an error code therwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>(serial-memory)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
