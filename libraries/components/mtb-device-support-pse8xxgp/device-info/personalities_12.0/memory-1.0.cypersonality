<?xml version="1.0" encoding="utf-8"?>

<!--****************************************************************************
* \file memory-1.0.cypersonality
* \version 1.0
*
* \brief
* Memory personality description file.
*
********************************************************************************
* \copyright
* Copyright (c) (2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*****************************************************************************-->

<PersonalityTemplate id="memory" name="Memory Regions" version="1.0" xmlns="http://cypress.com/xsd/cyhwpersonality_v10">
  <Constants>
    <Const id="MAX_REGIONS" value="256" />
    <Const id="MAX_CORES" value="4" />
    <Const id="MAX_VIEW_MAPS" value="4" />
    <Const id="MAX_MEMORIES" value="32" />
    <Const id="MEMORY_LOCATION_PREFIX" value="IFX_MEMORY_TYPE_" />
    <Const id="DEBUG" value="false" />
  </Constants>

  <VirtualResourceDefinition ipblock="VirtualResource" type="vres">
    <VirtualResourceDefinition type="reserved_memory_region" display_name="Reserved Region $idx" display_path="Memory" display_mode="DYNAMIC" count="25" />
    <VirtualResourceDefinition type="memory" display_name="Memory" display_path="" count="1">
      <DependentBlock type="vres.reserved_memory_region"/>
    </VirtualResourceDefinition>
  </VirtualResourceDefinition>

  <FittingRules>
    <MappingRules>
      <IpBlock name="VirtualResource">
        <Param name="HAS_MEMORY_DATA" value="1" />
      </IpBlock>
      <Resource name="vres\.memory" />
      <OperatingMode value="MCU" />
    </MappingRules>
  </FittingRules>

  <ExposedMembers>
    <ExposedMember key="regionPhysMemIds" paramId="completeRegionPhysMemIds"/>
    <ExposedMember key="regionOffsets" paramId="completeRegionOffsets"/>
    <ExposedMember key="regionSizes" paramId="completeRegionSizes"/>
    <ExposedMember key="regionIds" paramId="completeRegionIds"/>
    <ExposedMember key="regionCores" paramId="completeRegionCores"/>
    <ExposedMember key="regionDescription$idx{0}" paramId="regionDescription$idx{0}" repeatCount="$MAX_REGIONS" />
    <ExposedMember key="regionReservedGUIDs" paramId="completeRegionReservedGUIDs"/>
    <ExposedMember key="maxSupportedRegions" paramId="maxSupportedRegions"/>
    <ExposedMember key="maxSupportedCores" paramId="maxSupportedCores"/>
    <ExposedMember key="maxSupportedViewMaps" paramId="maxSupportedViewMaps"/>
  </ExposedMembers>

  <Parameters>
    <ParamDoc id="pdlDocMemoryRegions" name="Memory Regions Help" group="Overview" linkText="Defines memory regions to generate partial linker scripts for in GeneratedSource." visible="true" default="" desc="" />
    <ParamDoc id="pdlDocSummary" name="Summary Help" group="Overview" linkText="Displays a live image of how memory has been configured." visible="true" default="" desc="" />
    <ParamDoc id="pdlDocReadMe" name="Read Me Help" group="Overview" linkText="Provides static documentaion for the physical memories available in the design." visible="true" default="" desc="" />

    <ParamString id="cfgFileName" default="`${cy_design_filename() . &quot;.cyqspi&quot;}`" visible="$DEBUG" editable="false" group="DEBUG" name="cfgFileName" desc="" />
    <ParamString id="cfgFilePath" default="`${cy_design_path() . &quot;/&quot; . cfgFileName}`" visible="$DEBUG" editable="false" group="DEBUG" name="cfgFilePath" desc="" />
    <ParamCustom id="configurator" name="QSPI Configurator" group="Memory Definition Tools" default="0" path="`${cy_tools_path(&quot;qspi-configurator&quot;) . &quot;/qspi-configurator&quot;}`" visible="true" editable="true" desc="Launch QSPI Configurator tool.">
      <Arg value="`${&quot;--config=&quot; . cfgFilePath}`" />
      <Arg value="`${&quot;--output-dir=&quot; . cy_codegen_path()}`" />
    </ParamCustom>

    <!--Constants defined for use by the tool for error checking.-->
    <ParamRange id="maxSupportedRegions" editable="false" visible="$DEBUG" default="$MAX_REGIONS" min="$MAX_REGIONS" max="$MAX_REGIONS" resolution="1" group="DEBUG" name="maxSupportedRegions" desc="The maximum number of regions the tool should allow to be created (since it is the most the personality is defined to be able to handle. This is an arbirarily large number." />
    <ParamRange id="maxSupportedCores" editable="false" visible="$DEBUG" default="$MAX_CORES" min="$MAX_CORES" max="$MAX_CORES" resolution="1" group="DEBUG" name="maxSupportedCores" desc="The maximum number of available Cores the personality is defined to be able to handle. If an MPN with more needs to be supported this file will need to be updated to accomidate it." />
    <ParamRange id="maxSupportedViewMaps" editable="false" visible="$DEBUG" default="$MAX_VIEW_MAPS" min="$MAX_VIEW_MAPS" max="$MAX_VIEW_MAPS" resolution="1" group="DEBUG" name="maxSupportedViewMaps" desc="The maximum number of available physical memory view maps the personality is defined to be able to handle. If an MPN with more needs to be supported this file will need to be updated to accomidate it." />

    <ParamString id="numCores" default="`${splitCount(getVirtualCoreDefineNames())}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="numCores" desc="" />
    <Repeat count="$MAX_CORES">
      <ParamString id="coreId$idx{0}" default="`${$idx{0} &lt; numCores ? splitAt(getVirtualCoreDefineNames(), $idx{0}) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG" name="coreId$idx{0}" desc="" />
      <ParamString id="coreShortName$idx{0}" default="`${getCoreShortDefine(coreId$idx{0})}`" editable="false" visible="$DEBUG" group="DEBUG" name="coreShortName$idx{0}" desc="" />
    </Repeat>
    <ParamString id="numMemories" default="`${splitCount(memoryIds())}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="numMemories" desc="" />
    <Repeat count="$MAX_MEMORIES">
      <ParamString id="memoryId$idx{0}" default="`${$idx{0} &lt; numMemories ? splitAt(memoryIds(), $idx{0}) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG" name="memoryId$idx{0}" desc="" />
    </Repeat>

    <!--Set by the tool as semicolon separated string lists. The values must be sorted by physical memory id with a secondary sort on the region offset.-->
    <!--These are parallel data structures so index i into each of them gets the relevant data for region i.-->
    <ParamString id="regionPhysMemIds" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionPhysMemIds" desc="Semicolon separated list of the physical memory the region is defined in. The memory must be known to the current design (i.e. MPN/External memory)." />
    <ParamString id="regionOffsets" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionOffsets" desc="Semicolon separated list of the offset defined for the region (0 to size). Must be within the physical memory's range." />
    <ParamString id="regionSizes" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionSizes" desc="Semicolon separated list of the size defined for the region (0 to size). Must be within the physical memory's range." />
    <ParamString id="regionIds" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionIds" desc="Semicolon separated list of the id for each defined region. The value is required to be a legal identifier and to be unique from each other." />
    <ParamString id="regionCores" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionCores" desc="Semicolon separated list of comma separated list of cores defined for the region. Must be known cores to the MPN." />
    <ParamString id="regionReservedGUIDs" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionReservedGUIDs" desc="Semicolon separated list of guids defined for the region." />
    <Repeat count="$MAX_REGIONS">
      <ParamString id="regionDescription$idx{0}" default="" editable="true" visible="$DEBUG" group="DEBUG" name="regionDescription$idx{0}" desc="Description of the memory region." />
    </Repeat>

    <ParamString id="completeRegionPhysMemIds" default="`${getRegionPhysMemIds()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionPhysMemIds" desc="" />
    <ParamString id="completeRegionOffsets" default="`${getRegionOffsets()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionOffsets" desc="" />
    <ParamString id="completeRegionSizes" default="`${getRegionSizes()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionSizes" desc="" />
    <ParamString id="completeRegionIds" default="`${getRegionIds()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionIds" desc="" />
    <ParamString id="completeRegionCores" default="`${getRegionCores()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionCores" desc="" />
    <ParamString id="completeRegionReservedGUIDs" default="`${getRegionReservedGUIDs()}`" editable="false" visible="$DEBUG" group="DEBUG" name="completeRegionReservedGUIDs" desc="" />

    <!--Calculated values pulled out of the stored region data.-->
    <ParamRange id="numRegionsDefined" default="`${splitCount(completeRegionOffsets)}`" min="0" max="`${maxSupportedRegions}`" resolution="1" editable="false" visible="$DEBUG" group="DEBUG" name="numRegionsDefined" desc="" />
    <Repeat count="$MAX_REGIONS">
      <ParamString id="regionPhysMemId_$idx" default="`${$idx &lt; numRegionsDefined ? splitAt(completeRegionPhysMemIds, $idx) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionPhysMemId_$idx" desc="" />
      <ParamString id="regionOffset_$idx" default="`${$idx &lt; numRegionsDefined ? splitAt(completeRegionOffsets, $idx) : &quot;0&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionOffset_$idx" desc="" />
      <ParamString id="regionSize_$idx" default="`${$idx &lt; numRegionsDefined ? splitAt(completeRegionSizes, $idx) : &quot;0&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionSize_$idx" desc="" />
      <ParamString id="regionId_$idx" default="`${$idx &lt; numRegionsDefined ? splitAt(completeRegionIds, $idx) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionId_$idx" desc="" />
      <ParamString id="regionCores_$idx" default="`${$idx &lt; numRegionsDefined ? splitAt(completeRegionCores, $idx) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionCores_$idx" desc="" />
      <ParamString id="regionEndOffset_$idx" default="`${toHex(regionOffset_$idx + regionSize_$idx, 8)}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="regionEndOffset_$idx" desc="" />

      <ParamString id="numRegionCoresAssigned_$idx" default="`${$idx &lt; numRegionsDefined ? splitCount(regionCores_$idx, &quot;,&quot;) : &quot;0&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx" name="numRegionCoresAssigned_$idx" desc="" />
      <Repeat count="$MAX_CORES">
        <ParamString id="regionCore$idx{0}_$idx{1}" default="`${$idx{1} &lt; numRegionsDefined &amp;&amp; $idx{0} &lt; numRegionCoresAssigned_$idx{1} ? splitAt(regionCores_$idx{1}, $idx{0}, &quot;,&quot;) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx{1}" name="regionCore$idx{0}_$idx{1}" desc="" />
        <ParamString id="regionViewMapsForCore$idx{0}_$idx{1}" default="`${$idx{1} &lt; numRegionsDefined &amp;&amp; $idx{0} &lt; numRegionCoresAssigned_$idx{1} ? memoryViewMaps(regionPhysMemId_$idx{1}, regionCore$idx{0}_$idx{1}) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx{1}" name="regionViewMapsForCore$idx{0}_$idx{1}" desc="" />
        <ParamString id="numRegionViewMapsForCore$idx{0}_$idx{1}" default="`${splitCount(regionViewMapsForCore$idx{0}_$idx{1})}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx{1}" name="numRegionViewMapsForCore$idx{0}_$idx{1}" desc="" />
        <Repeat count="$MAX_VIEW_MAPS">
          <ParamString id="regionViewMap$idx{0}Id_$idx{1}_$idx{2}" default="`${$idx{0} &lt; numRegionViewMapsForCore$idx{1}_$idx{2} ? splitAt(regionViewMapsForCore$idx{1}_$idx{2}, $idx{0}) : &quot;&quot;}`" editable="false" visible="$DEBUG" group="DEBUG/region$idx{1}" name="regionViewMap$idx{0}Id_$idx{1}_$idx{2}" desc="" />
        </Repeat>
      </Repeat>
    </Repeat>
  </Parameters>
  <DRCs>
    <!-- Region must be contained in a memory -->
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; !hasMemory(regionPhysMemId_$idx)}`" type="ERROR"
         text="Memory region '`${regionId_$idx}`' is allocated to the non-existent physical memory '`${memoryDisplayName(regionPhysMemId_$idx)}`'."
         repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Unallocate memory region '`${regionId_$idx}`'">
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${splitRemoveAt(completeRegionPhysMemIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${splitRemoveAt(completeRegionOffsets, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitRemoveAt(completeRegionSizes, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${splitRemoveAt(completeRegionIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitRemoveAt(completeRegionCores, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${splitRemoveAt(completeRegionReservedGUIDs, $idx)}`" valid="true" />
      </FixItBatch>
    </DRC>
    <!-- regionOffset_$idx must be within memorySize -->
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; hasMemory(regionPhysMemId_$idx) &amp;&amp; regionOffset_$idx &gt;= memorySize(regionPhysMemId_$idx)}`" type="ERROR"
         text="Memory region '`${regionId_$idx}`' must begin within physical memory '`${memoryDisplayName(regionPhysMemId_$idx)}`'."
         repeatCount="$MAX_REGIONS" paramId="$idx" />
    <!-- regionOffset_$idx is unsigned so it cannot be less than 0 -->
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; hasMemory(regionPhysMemId_$idx) &amp;&amp; regionOffset_$idx &lt; memorySize(regionPhysMemId_$idx) &amp;&amp; regionEndOffset_$idx &gt; memorySize(regionPhysMemId_$idx)}`" type="ERROR"
         text="Memory region '`${regionId_$idx}`' does not fit within physical memory '`${memoryDisplayName(regionPhysMemId_$idx)}`'."
         repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Change size of memory region '`${regionId_$idx}`' to `${toHex(memorySize(regionPhysMemId_$idx) - regionOffset_$idx)}`">
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitSetAt(completeRegionSizes, $idx, toHex(memorySize(regionPhysMemId_$idx) - regionOffset_$idx))}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${completeRegionCores}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`" />
      </FixItBatch>
    </DRC>
    <!-- Region must have valid cores -->
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 0 &lt; numRegionCoresAssigned_$idx &amp;&amp; !hasCore(regionCore0_$idx)}`" type="ERROR"
         text="Invalid core0 '`${regionCore0_$idx}`'" repeatCount="$MAX_REGIONS" paramId="$idx" />
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 1 &lt; numRegionCoresAssigned_$idx &amp;&amp; !hasCore(regionCore1_$idx)}`" type="ERROR"
         text="Invalid core1 '`${regionCore1_$idx}`'" repeatCount="$MAX_REGIONS" paramId="$idx" />
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 2 &lt; numRegionCoresAssigned_$idx &amp;&amp; !hasCore(regionCore2_$idx)}`" type="ERROR"
         text="Invalid core2 '`${regionCore2_$idx}`'" repeatCount="$MAX_REGIONS" paramId="$idx" />
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 3 &lt; numRegionCoresAssigned_$idx &amp;&amp; !hasCore(regionCore3_$idx)}`" type="ERROR"
         text="Invalid core3 '`${regionCore3_$idx}`'" repeatCount="$MAX_REGIONS" paramId="$idx" />
    <!-- Region should be visible to all assigned cores -->
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 0 &lt; numRegionCoresAssigned_$idx &amp;&amp; numRegionViewMapsForCore0_$idx &lt;= 0}`" type="ERROR"
         text="Memory `${memoryDisplayName(regionPhysMemId_$idx)}` is not accessible by core `${regionCore0_$idx}`" repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Remove unaccessible core, `${regionCore0_$idx}`">
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitSetAt(completeRegionCores, $idx, splitRemoveAt(splitAt(completeRegionCores,$idx), 0, &quot;,&quot;))}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />

        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${completeRegionSizes}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
      </FixItBatch>
      <FixItBatch description="Unallocate memory region '`${regionId_$idx}`'">
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${splitRemoveAt(completeRegionPhysMemIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${splitRemoveAt(completeRegionOffsets, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitRemoveAt(completeRegionSizes, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${splitRemoveAt(completeRegionIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitRemoveAt(completeRegionCores, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${splitRemoveAt(completeRegionReservedGUIDs, $idx)}`" valid="true" />
      </FixItBatch>
    </DRC>
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 1 &lt; numRegionCoresAssigned_$idx &amp;&amp; numRegionViewMapsForCore1_$idx &lt;= 0}`" type="ERROR"
         text="Memory `$memoryDisplayName({regionPhysMemId_$idx)}` is not accessible by core `${regionCore1_$idx}`" repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Remove unaccessible core, `${regionCore1_$idx}`">
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitSetAt(completeRegionCores, $idx, splitRemoveAt(splitAt(completeRegionCores,$idx), 1, &quot;,&quot;))}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />

        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${completeRegionSizes}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
      </FixItBatch>
      <FixItBatch description="Unallocate memory region '`${regionId_$idx}`'">
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${splitRemoveAt(completeRegionPhysMemIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${splitRemoveAt(completeRegionOffsets, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitRemoveAt(completeRegionSizes, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${splitRemoveAt(completeRegionIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitRemoveAt(completeRegionCores, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${splitRemoveAt(completeRegionReservedGUIDs, $idx)}`" valid="true" />
      </FixItBatch>
    </DRC>
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 2 &lt; numRegionCoresAssigned_$idx &amp;&amp; numRegionViewMapsForCore2_$idx &lt;= 0}`" type="ERROR"
         text="Memory `${memoryDisplayName(regionPhysMemId_$idx)}` is not accessible by core `${regionCore2_$idx}`" repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Remove unaccessible core, `${regionCore2_$idx}`">
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitSetAt(completeRegionCores, $idx, splitRemoveAt(splitAt(completeRegionCores,$idx), 2, &quot;,&quot;))}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />

        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${completeRegionSizes}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
      </FixItBatch>
      <FixItBatch description="Unallocate memory region '`${regionId_$idx}`'">
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${splitRemoveAt(completeRegionPhysMemIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${splitRemoveAt(completeRegionOffsets, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitRemoveAt(completeRegionSizes, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${splitRemoveAt(completeRegionIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitRemoveAt(completeRegionCores, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${splitRemoveAt(completeRegionReservedGUIDs, $idx)}`" valid="true" />
      </FixItBatch>
    </DRC>
    <DRC condition="`${$idx &lt; numRegionsDefined &amp;&amp; 3 &lt; numRegionCoresAssigned_$idx &amp;&amp; numRegionViewMapsForCore3_$idx &lt;= 0}`" type="ERROR"
         text="Memory `${memoryDisplayName(regionPhysMemId_$idx)}` is not accessible by core `${regionCore3_$idx}`" repeatCount="$MAX_REGIONS" paramId="$idx" >
      <FixItBatch description="Remove unaccessible core, `${regionCore3_$idx}`">
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitSetAt(completeRegionCores, $idx, splitRemoveAt(splitAt(completeRegionCores,$idx), 3, &quot;,&quot;))}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />

        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${completeRegionSizes}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${numRegionCoresAssigned_$idx &gt; 1}`" />
      </FixItBatch>
      <FixItBatch description="Unallocate memory region '`${regionId_$idx}`'">
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${splitRemoveAt(completeRegionPhysMemIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${splitRemoveAt(completeRegionOffsets, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitRemoveAt(completeRegionSizes, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${splitRemoveAt(completeRegionIds, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${splitRemoveAt(completeRegionCores, $idx)}`" valid="true" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${splitRemoveAt(completeRegionReservedGUIDs, $idx)}`" valid="true" />
      </FixItBatch>
    </DRC>
    <!-- Regions must not overlap -->
    <DRC condition="`${($idx+1) &lt; numRegionsDefined &amp;&amp; regionPhysMemId_$idx eq getParamValue(&quot;regionPhysMemId_&quot; . ($idx+1)) &amp;&amp; regionEndOffset_$idx &gt; getParamValue(&quot;regionOffset_&quot; . ($idx+1)) }`"
         type="ERROR" repeatCount="255"
         text="Memory region '`${regionId_$idx}`' overlaps with memory region '`${getParamValue(&quot;regionId_&quot; . ($idx+1))}`'." paramId="$idx" >
      <FixItBatch description="Change size of memory region '`${regionId_$idx}`' to `${toHex(floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx))}`">
        <FixIt action="SET_PARAM" target="regionSizes" value="`${splitSetAt(completeRegionSizes, $idx, toHex(floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx)))}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionPhysMemIds" value="`${completeRegionPhysMemIds}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionOffsets" value="`${completeRegionOffsets}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionIds" value="`${completeRegionIds}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionCores" value="`${completeRegionCores}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
        <FixIt action="SET_PARAM" target="regionReservedGUIDs" value="`${completeRegionReservedGUIDs}`" valid="`${floor((getParamValue(&quot;regionOffset_&quot; . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`" />
      </FixItBatch>
    </DRC>
    <!-- Regions that have different core sets should not share a memory block -->
    <DRC condition="`${($idx+1) &lt; numRegionsDefined &amp;&amp; regionPhysMemId_$idx eq getParamValue(&quot;regionPhysMemId_&quot; . ($idx+1)) &amp;&amp; regionEndOffset_$idx &lt;= getParamValue(&quot;regionOffset_&quot; . ($idx+1)) &amp;&amp; (regionEndOffset_$idx-1)/memoryAlignment(regionPhysMemId_$idx) == getParamValue(&quot;regionOffset_&quot; . ($idx+1))/memoryAlignment(regionPhysMemId_$idx) &amp;&amp; regionCores_$idx ne getParamValue(&quot;regionCores_&quot; . ($idx+1)) }`"
         type="INFO" repeatCount="255"
         text="Memory regions '`${regionId_$idx}`' and '`${getParamValue(&quot;regionId_&quot; . ($idx+1))}`' share the same erase block (size `${toHex(memoryAlignment(regionPhysMemId_$idx))}`) but are assigned to different cores. Reprogramming one core will erase the data used by the other core." paramId="$idx" />
  </DRCs>
  <ConfigFirmware>
    <!-- cymem_memory_types.h -->
    <ConfigFile repeatCount="1" name="cymem_memory_types.h">
      <Line value="/* This file is automatically generated. */"/>
      <Line value="#if !defined(CYMEM_MEMORY_TYPES_H)" />
      <Line value="#define CYMEM_MEMORY_TYPES_H"/>
      <Line value=""/>
      <Repeat repeatCount="`${numMemories}`">
        <Line value="#define $MEMORY_LOCATION_PREFIX`${memoryId$idx}` ($idx)" />
      </Repeat>
      <Line value=""/>
      <Line value="#define IS_SMIF_MEMORY(mem) ( \"/>
      <Repeat repeatCount="`${numMemories}`">
        <Line value="    (mem == $MEMORY_LOCATION_PREFIX`${memoryId$idx}`) ? 1 : \" include="`${hasMatch(memoryId$idx, &quot;^SMIF&quot;)}`" />
      </Repeat>
      <Line value="    0 \"/>
      <Line value=")"/>
      <Line value=""/>
      <Line value="#endif /* CYMEM_MEMORY_TYPES_H */"/>
    </ConfigFile>

    <!-- cymem_memory_locations.h -->
    <ConfigFile repeatCount="1" name="cymem_memory_locations.h">
      <Line value="/* This file is automatically generated. */"/>
      <Line value="#if !defined(CYMEM_MEMORY_LOCATIONS_H)" />
      <Line value="#define CYMEM_MEMORY_LOCATIONS_H"/>
      <Line value=""/>
      <Line value="#include &quot;cymem_memory_types.h&quot;"/>
      <Line value=""/>
      <Repeat repeatCount="`${numCores}`">
        <Repeat repeatCount="`${numMemories}`">
          <Repeat repeatCount="`${numRegionsDefined}`">
            <Line include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`" value="#define CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_LOCATION $MEMORY_LOCATION_PREFIX`${regionPhysMemId_$idx{0}}`" />
          </Repeat>
        </Repeat>
      </Repeat>

      <Line value=""/>
      <Line value="#endif /* CYMEM_MEMORY_LOCATIONS_H */"/>
    </ConfigFile>

    <!-- GNU ld -->
    <ConfigFile repeatCount="`${numCores}`" name="cymem_gnu_`${coreShortName$idx{0}}`.ld">
      <Line value="/* This file is automatically generated. */"/>
      <Line value=""/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="CYMEM_`${coreShortName$idx{4}}`_`${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}`_START = `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}`;" />
            </Repeat>
          </Repeat>
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_SIZE = `${toHex(regionSize_$idx{0}, 8)}`;" />
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_OFFSET = `${toHex(regionOffset_$idx{0}, 8)}`;" />
        </Repeat>
      </Repeat>
    </ConfigFile>
    <ConfigFile repeatCount="`${numCores}`" name="cymem_gnu_regions_`${coreShortName$idx{0}}`.ld">
      <Line value="/* This file is automatically generated. */"/>
      <Line value="/* MEMORY */"/>
      <Line value="/* { */"/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="    `${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}` : ORIGIN = `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}`, LENGTH = `${toHex(regionSize_$idx{2}, 8)}`" />
            </Repeat>
          </Repeat>
        </Repeat>
      </Repeat>
      <Line value="/* } */"/>
    </ConfigFile>
    <!-- armlink -->
    <ConfigFile repeatCount="`${numCores}`" name="cymem_armlink_`${coreShortName$idx{0}}`.sct">
      <Line value="; This file is automatically generated."/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="#define CYMEM_`${coreShortName$idx{4}}`_`${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}`_START `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}`" />
            </Repeat>
          </Repeat>
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="#define CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_SIZE `${toHex(regionSize_$idx{0}, 8)}`" />
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="#define CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_OFFSET `${toHex(regionOffset_$idx{0}, 8)}`" />
        </Repeat>
      </Repeat>
    </ConfigFile>
    <!-- ilinkarm -->
    <ConfigFile repeatCount="`${numCores}`" name="cymem_ilinkarm_`${coreShortName$idx{0}}`.icf">
      <Line value="// This file is automatically generated."/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="define exported symbol CYMEM_`${coreShortName$idx{4}}`_`${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}`_START = `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}`;" />
            </Repeat>
          </Repeat>
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="define exported symbol CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_SIZE = `${toHex(regionSize_$idx{0}, 8)}`;" />
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="define exported symbol CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_OFFSET = `${toHex(regionOffset_$idx{0}, 8)}`;" />
        </Repeat>
      </Repeat>
    </ConfigFile>
    <ConfigFile repeatCount="`${numCores}`" name="cymem_ilinkarm_regions_`${coreShortName$idx{0}}`.icf">
      <Line value="// This file is automatically generated."/>
      <Line value="// define memory with size = 4G;"/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="define region `${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}` = [from `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}` size `${toHex(regionSize_$idx{2}, 8)}`];" />
            </Repeat>
          </Repeat>
        </Repeat>
      </Repeat>
    </ConfigFile>
    <!-- C header file -->
    <ConfigFile repeatCount="`${numCores}`" name="cymem_`${coreShortName$idx{0}}`.h">
      <Line value="/* This file is automatically generated. */"/>
      <Line value="#if !defined(CYMEM_`${coreShortName$idx{0}}`_H)" />
      <Line value="#define CYMEM_`${coreShortName$idx{0}}`_H"/>
      <Line value=""/>
      <Repeat repeatCount="`${numMemories}`">
        <Repeat repeatCount="`${numRegionsDefined}`">
          <Repeat repeatCount="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} ? numRegionCoresAssigned_$idx{0} : 0}`">
            <Repeat repeatCount="`${regionCore$idx{0}_$idx{1} eq coreId$idx{3} ? numRegionViewMapsForCore$idx{0}_$idx{1} : 0}`">
              <Line value="#define CYMEM_`${coreShortName$idx{4}}`_`${regionId_$idx{2}}``${memoryViewMapSuffix(regionViewMap$idx{0}Id_$idx{1}_$idx{2})}`_START `${toHex(memoryOffsetToAddress(coreId$idx{4}, regionViewMap$idx{0}Id_$idx{1}_$idx{2}, regionPhysMemId_$idx{2}, regionOffset_$idx{2}), 8)}`u" />
            </Repeat>
          </Repeat>
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="#define CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_SIZE `${toHex(regionSize_$idx{0}, 8)}`u" />
          <Line
            include="`${regionPhysMemId_$idx{0} eq memoryId$idx{1} &amp;&amp; splitFind(regionCores_$idx{0}, coreId$idx{2}, &quot;,&quot;) &gt;= 0}`"
            value="#define CYMEM_`${coreShortName$idx{2}}`_`${regionId_$idx{0}}`_OFFSET `${toHex(regionOffset_$idx{0}, 8)}`u" />
        </Repeat>
      </Repeat>
      <Line value="" />
      <Line value="#endif /* CYMEM_`${coreShortName$idx{0}}`_H */"/>
    </ConfigFile>
  </ConfigFirmware>
</PersonalityTemplate>
